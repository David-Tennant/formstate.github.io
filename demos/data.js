var data = {"contents":[{"pageSubDirName":"all","type":"html","html":"<a href=\"https://github.com/formstate/formstate\" class=\"github-corner\" aria-label=\"Visit Project\"><svg width=\"80\" height=\"80\" viewBox=\"0 0 250 250\" style=\"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;\" aria-hidden=\"true\"><path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"></path><path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"></path><path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>"},{"type":"html","pageSubDirName":"all","html":"<div class=\"eze-markdown\">\n      <h1>\n      FormState Demos\n      <a name=\"sample-subheading\" class=\"heading-anchor\" href=\"#all\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h2></div>"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><blockquote>\n<p>In case you came here directly please note <a href=\"https://formstate.github.io\" target=\"_blank\">that we do have hand crafted docs</a> which explain a lot of the reasoning behind formstate ðŸŒ¹</p>\n</blockquote>\n<h1>\n      Creating a Field\n      <a name=\"creating-a-field\" class=\"heading-anchor\" href=\"#creating-a-field\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p>Note that because you write your own Field components you get:</p>\n<ul>\n<li>To design your fields any way you want with your look an feel.</li>\n<li>Keep your logic seperate from UI rendering that helps greatly with testing.</li>\n<li>We can work with complex data types with ease.</li>\n</ul>\n<p>As an example lets pick an existing UI library called <a href=\"http://www.material-ui.com/\" target=\"_blank\">material-ui</a>.</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\">npm install @materialui/core --save-dev</div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>The only difficulty is <a href=\"https://material-ui.com/demos/text-fields/\" target=\"_blank\">reading the material-ui docs to figure out how to create a nice text field</a>. Once that is done we just plonk the provided JSX and wire it to our <code>FieldState</code>.</p>\n<p>Our <code>Field</code> will take a <code>FieldState</code> and render the components (material-ui components in this case, but imagine any styled components you might have ... or create in the future):</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\"><span class=\"hljs-comment\">/** Material UI */</span>\n<span class=\"hljs-keyword\">import</span> { FormControl, InputLabel, Input, FormHelperText } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@material-ui/core'</span>;\n\n<span class=\"hljs-comment\">/** Field Props */</span>\n<span class=\"hljs-keyword\">export</span> type FieldProps = {\n  <span class=\"hljs-comment\">/** This library : fieldState */</span>\n  fieldState: FieldState&lt;string&gt;\n\n  <span class=\"hljs-comment\">/**\n   * Any UI stuff you need\n   * Use your imagination ðŸ¦„!\n   */</span>\n  id: string,\n  <span class=\"hljs-attr\">label</span>: string,\n}\n\n<span class=\"hljs-comment\">/**\n * Observer Field component.\n * Wires FieldState to any native or library elements you want.\n * Use your imagination ðŸ¦„!\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> Field = observer(<span class=\"hljs-function\">(<span class=\"hljs-params\">props: FieldProps</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FormControl</span> <span class=\"hljs-attr\">fullWidth</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">InputLabel</span>\n      <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>\n      <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">{props.id}</span>&gt;</span>\n      {props.label}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">InputLabel</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span>\n      <span class=\"hljs-attr\">fullWidth</span>\n      <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{props.id}</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{props.fieldState.value}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =&gt;</span> { props.fieldState.onChange(e.target.value) }}\n    /&gt;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FormHelperText</span> <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>&gt;</span>{props.fieldState.error}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">FormHelperText</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">FormControl</span>&gt;</span>\n));</span></div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Once that is done you now get to use your new shiny <code>Field</code> with complete compile time safety.</p></div>"},{"type":"app","index":1,"htmlFileName":"app-1.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render } from './mui';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState } from '../../index';\nconst fieldState = new FieldState('').validators((val) => !val.trim() && 'Value required');\n\nrender(() => <div>\n  <Field\n    id=\"first\"\n    label=\"Provide me some value\"\n    fieldState={fieldState} />\n  {!!fieldState.value.trim() && <p>Current Field Value = {fieldState.value}</p>}\n  {fieldState.hasError && <p>Current Field Error = {fieldState.error}</p>}\n</div>);\n"}],"height":"200px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h1>\n      Validation Triggering\n      <a name=\"validation-triggering\" class=\"heading-anchor\" href=\"#validation-triggering\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p>How you decide to do trigger a validation check depends on the UX you are going for and there are <a href=\"https://uxdesign.cc/forms-need-validation-2ecbccbacea1\" target=\"_blank\">quite a few options</a>. Fortunately by not tieing you in to <em>our Fields</em> and letting you create your own means, you can easily make a choice and support the pattern you want in your components.</p>\n<p>The default is the simplest, whenever <code>onChange</code> is called, a validation request is queued in the field state. So if you edit the below field you will see the error pop up till the field becomes valid.</p></div>"},{"type":"app","index":2,"htmlFileName":"app-2.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render, Button } from './mui';\nimport { observer } from 'mobx-react';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState } from '../../index';\nconst fieldState = new FieldState('').validators((val) => val !== 'foo' && \"I only allow 'foo'\");\n\nrender(() => <div>\n  <Field\n    id=\"first\"\n    label=\"The magic word is foo\"\n    fieldState={fieldState} />\n</div>);\n"}],"height":"200px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>You can disable this by passing in <code>autoValidationEnabled: false,</code> to the FieldState constructor as shown below. Now you get to decide when you want to call <code>validate</code> e.g. on a button click:</p></div>"},{"type":"app","index":3,"htmlFileName":"app-3.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render, Button, vertical } from './mui';\nimport { observer } from 'mobx-react';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState } from '../../index';\nconst fieldState = new FieldState('').disableAutoValidation().validators((val) => val !== 'foo' && \"I only allow 'foo'\");\n\nrender(() => <div className={vertical}>\n  <Field\n    id=\"first\"\n    label=\"Provide me some foo\"\n    fieldState={fieldState} />\n  <Button\n    onClick={() => fieldState.validate()}>\n    Click me to validate\n  </Button>\n</div>);\n"}],"height":"200px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>However the best place to call <code>validate</code> is inside an html <code>form</code> element. The following example demonstrates this.</p>\n<blockquote>\n<p>Note that after a failed validation attempt you might want to enable the automatic validation as we do below.</p>\n</blockquote></div>"},{"type":"app","index":4,"htmlFileName":"app-4.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render, Button, vertical } from './mui';\nimport { observer } from 'mobx-react';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState } from '../../index';\nconst fieldState = new FieldState('').disableAutoValidation().validators((val) => val !== 'foo' && \"I only allow 'foo'\");\n\nrender(() => <form className={vertical} onSubmit={async (e) => {\n  e.preventDefault();\n  const res = await fieldState.validate();\n  if (res.hasError) {\n    fieldState.enableAutoValidation();\n    return;\n  }\n  console.log('Validated Value:', fieldState.$);\n}}>\n  <Field\n    id=\"first\"\n    label=\"foo is the value you are looking for\"\n    fieldState={fieldState} />\n  <br />\n  <Button\n    type=\"submit\">\n    Click me to validate, or press enter in the input field\n  </Button>\n</form>);\n"}],"height":"200px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Another common validation pattern is to do it after first blur and then enable it for automatic validation. This can be easily coded into the <code>Field</code>. Let&#39;s recreate our <code>Field</code> with this behavior baked in:</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\"><span class=\"hljs-comment\">/**\n * OnBlur it will validate and enable auto validation\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> FieldBlur = observer(<span class=\"hljs-function\">(<span class=\"hljs-params\">props: FieldProps</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FormControl</span> <span class=\"hljs-attr\">fullWidth</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">InputLabel</span>\n      <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>\n      <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">{props.id}</span>&gt;</span>\n      {props.label}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">InputLabel</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span>\n      <span class=\"hljs-attr\">fullWidth</span>\n      <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{props.id}</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{props.fieldState.value}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =&gt;</span> { props.fieldState.onChange(e.target.value) }}\n\n      /** Always validate on blur */\n      onBlur={props.fieldState.enableAutoValidationAndValidate}\n    /&gt;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FormHelperText</span> <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>&gt;</span>{props.fieldState.error}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">FormHelperText</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">FormControl</span>&gt;</span>\n));</span></div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Now if you blur on any such <code>Field</code>s they do a validation and enable autoValidation to guide the user towards a valid state.</p></div>"},{"type":"app","index":5,"htmlFileName":"app-5.html","sources":[{"mode":"js","code":"/** React + MUI + mobx */\nimport * as React from 'react';\nimport { render, Button, vertical } from './mui';\nimport { observer } from 'mobx-react';\n\n/** Field */\nimport { FieldBlur } from './fieldBlur';\n\n/** FieldState */\nimport { FieldState, FormState } from '../../index';\n\nconst formState = new FormState({\n  foo: new FieldState('').disableAutoValidation().validators((val) => val !== 'foo' && \"I only allow 'foo'\"),\n  bar: new FieldState('').disableAutoValidation().validators((val) => val !== 'bar' && \"I only allow 'bar'\")\n})\nrender(() => <form className={vertical} onSubmit={async (e) => {\n  e.preventDefault();\n  const res = await formState.validate();\n  if (res.hasError) {\n    formState.enableAutoValidation();\n    return;\n  }\n  console.log('Validated Values:', formState.$.foo.$, formState.$.bar.$);\n}}>\n  <FieldBlur\n    id=\"first\"\n    label=\"foo is the value you are looking for\"\n    fieldState={formState.$.foo} />\n  <br />\n  <FieldBlur\n    id=\"second\"\n    label=\"Lets go to the bar\"\n    fieldState={formState.$.bar} />\n  <br />\n  <Button\n    type=\"submit\">\n    Click me to validate, or press enter in some input field.\n  </Button>\n</form>);\n"}],"height":"300px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h1>\n      FormState\n      <a name=\"formstate\" class=\"heading-anchor\" href=\"#formstate\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p><a href=\"https://formstate.github.io\" target=\"_blank\">We think the docs cover it well</a>. You can also see it in use in onBlur example above as well. But here is another example where we have a the following requirements:</p>\n<ul>\n<li>nested structure of <code>Car</code>s containing <code>Feature</code>s.</li>\n<li>a Car has a name which is required.</li>\n<li>a Car must have at least one Feature.</li>\n<li>each Feature has a name which is required.</li>\n<li>we want to allow submit only once all these requirements are met.</li>\n</ul></div>"},{"type":"app","index":6,"htmlFileName":"app-6.html","sources":[{"mode":"js","code":"/** React + MUI + mobx */\nimport * as React from 'react';\nimport { render, Button, ErrorText, vertical } from './mui';\nimport { observer } from 'mobx-react';\nimport { observable, action } from 'mobx';\nimport { resize } from 'eze/lib/client';\nimport { Vertical, Horizontal } from './gls';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState, FormState } from '../../index';\n\n\n/** Our validations */\nconst requiredWithMessage\n  = (message: string) =>\n    (val: string) => !val.trim() && message;\nconst atLeastOneWithMessage\n  = (message: string) =>\n    (val: any[]) => !val.length && message;\n\n/**\n * TypeScript tip:\n * Specialize your generic types to make annotations easier\n **/\ntype Name = FieldState<string>;\ntype Feature = FormState<{ name: Name }>;\ntype Features = FormState<Feature[]>;\ntype Car = FormState<{ name: Name, features: Features }>;\ntype Cars = FormState<Car[]>;\n\nclass AppState {\n  @observable cars: Cars = new FormState([]).validators(atLeastOneWithMessage(\"At least on car is needed\"));\n\n  @action addACar = () => {\n    const car: Car = new FormState({\n      name: new FieldState('').validators(requiredWithMessage(\"Car needs a name\")),\n      features: new FormState([]).validators(atLeastOneWithMessage(\"Car must have at least one feature\")),\n    })\n    this.cars.$.push(car);\n  }\n\n  @action addAFeatureToACar = (car: Car) => {\n    const feature: Feature\n      = new FormState({\n        name: new FieldState('')\n          .validators(requiredWithMessage(\"Feature needs a name\"))\n      });\n    car.$.features.$.push(feature);\n  }\n}\nconst state = new AppState();\n\nrender(() => {\n  return (<form className={vertical} onSubmit={async (e) => {\n    e.preventDefault();\n    const res = await state.cars.validate();\n    if (res.hasError) {\n      return;\n    }\n    alert('Valid!');\n  }}>\n    <Vertical>\n      {/** Add cars button */}\n      <Button onClick={state.addACar}>\n        Add {state.cars.$.length ? 'another' : 'a'} car\n      </Button>\n\n      {/** For each car */}\n      {state.cars.$.map((car, carKey) => {\n        return (\n          <Vertical key={carKey} style={{ marginLeft: '10px' }}>\n            <Field\n              id={\"carName\" + carKey}\n              label=\"Car Name\"\n              fieldState={car.$.name}\n            />\n\n            {/** For each feature in car */}\n            {!!car.$.features.$.length\n              && <Vertical style={{ padding: '10px', border: '1px dotted #333' }}>\n                {car.$.features.$.map((feature, featureKey) => {\n                  return (\n                    <Field\n                      key={featureKey}\n                      id={carKey + \"featureName\" + featureKey}\n                      label=\"Feature Name\"\n                      fieldState={feature.$.name}\n                    />\n                  );\n                })}\n              </Vertical>\n            }\n\n            {car.hasError && <ErrorText>Car has error: {car.error}</ErrorText>}\n            <Button onClick={() => state.addAFeatureToACar(car)}>\n              Add {car.$.features.$.length ? 'another' : 'a'} feature\n            </Button>\n          </Vertical>\n        );\n      })}\n\n      {/** Over all form submit */}\n      <Horizontal verticalAlign=\"center\">\n        <Button\n          type=\"submit\">\n          Submit\n        </Button>\n        {state.cars.hasError && <ErrorText>Form has error: {state.cars.error}</ErrorText>}\n      </Horizontal>\n    </Vertical>\n  </form>);\n});\n"}],"height":"600px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h1>\n      Cross field validation\n      <a name=\"cross-field-validation\" class=\"heading-anchor\" href=\"#cross-field-validation\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p>Call <code>FormState().compose()</code> whenever you want to compose the FieldState -&gt; auto validate FormState behaviour. Form validators only run automatically once all the sub Fields (or Forms) are valid, so you don&#39;t need to worry about invalid sub fields when doing form validation.</p></div>"},{"type":"app","index":7,"htmlFileName":"app-7.html","sources":[{"mode":"js","code":"/** React + MUI + mobx */\nimport * as React from 'react';\nimport { render, Button, ErrorText, vertical } from './mui';\nimport { observer } from 'mobx-react';\nimport { observable, action } from 'mobx';\nimport { resize } from 'eze/lib/client';\nimport { Vertical, Horizontal } from './gls';\n\n/** Field */\nimport { Field } from './field';\n\n/** FieldState */\nimport { FieldState, FormState } from '../../index';\n\n\nconst nameRequired = (val: string) => !val && 'Name required';\nconst form = new FormState({\n  name1: new FieldState('').validators(nameRequired),\n  name2: new FieldState('').validators(nameRequired),\n})\n  .compose()\n  .validators(($) => $.name1.$ !== $.name2.$ && 'Names must match');\n\nrender(() => {\n  return (<form className={vertical} onSubmit={async (e) => {\n    e.preventDefault();\n    const res = await form.validate();\n    if (res.hasError) {\n      return;\n    }\n    alert('Valid!');\n  }}>\n    <Vertical>\n      <Field\n        id={\"name1\"}\n        label=\"Name\"\n        fieldState={form.$.name1}\n      />\n      <Field\n        id={\"name2\"}\n        label=\"Re-enter name\"\n        fieldState={form.$.name2}\n      />\n\n      {form.showFormError && <ErrorText>{form.formError}</ErrorText>}\n\n      {/** Over all form submit */}\n      <Horizontal verticalAlign=\"center\">\n        <Button\n          type=\"submit\">\n          Submit\n        </Button>\n\n        {form.hasError && <ErrorText>Form has error: {form.error}</ErrorText>}\n      </Horizontal>\n    </Vertical>\n  </form>);\n});\n"}],"height":"300px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h1>\n      Custom type TValue\n      <a name=\"custom-type-tvalue\" class=\"heading-anchor\" href=\"#custom-type-tvalue\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p>A fieldstate can work with any type. </p>\n<p>If your input only allows the user to input a Display that can be validly converted to TValue, then the complexity of converting between TValue-Display can be handled by your field component:</p>\n<ul>\n<li>TValue to Display can be done in the <code>value</code> of the component.</li>\n<li>Display to TValue can be one in the <code>onChange</code> of the component. </li>\n</ul>\n<p>Here is a number component that works on <code>value:string</code> and <code>TValue:number</code>:</p></div>"},{"type":"app","index":8,"htmlFileName":"app-8.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render, Button, ErrorText, labelClass, inputClass } from './mui';\nimport { observer } from 'mobx-react';\nimport { style } from 'typestyle';\nimport { Vertical } from './gls';\n\n/** FieldState */\nimport { FieldState } from '../../index';\n\n\n/** Example number FieldState */\nconst fieldState = new FieldState<number | null>(null)\n  .validators(\n    (val) => val == null && 'Value required',\n    (val) => val != null && val < 2 && 'Value must be greater than 2',\n);\n\n/** Example NumberInputField */\ntype NumberInputFieldProps = {\n  fieldState: FieldState<number | null>,\n  label: string\n};\nconst NumberInputField: React.SFC<NumberInputFieldProps> = observer((props: NumberInputFieldProps) => {\n  return (\n    <label>\n      <span className={labelClass}>{props.label}</span>\n      <input\n        className={inputClass}\n        type=\"number\"\n        /** \n         * Convert the TValue to Display\n         */\n        value={\n          props.fieldState.value == null\n            ? ''\n            : props.fieldState.value.toString()\n        }\n        /** \n         * Convert Display to the correct TValue in onChange \n         */\n        onChange={(e) => {\n          const strValue = e.target.value;\n          if (isNaN(+strValue)) {\n            props.fieldState.onChange(null);\n          } else {\n            props.fieldState.onChange(+strValue);\n          }\n        }}\n      />\n    </label>\n  );\n});\n\nrender(() => <Vertical margin={10}>\n  <NumberInputField\n    label=\"Example Number Input\"\n    fieldState={fieldState} />\n  {fieldState.hasError && <ErrorText>Current Field Error = {fieldState.error}</ErrorText>}\n  <Button onClick={() => fieldState.validate()}>Validate</Button>\n</Vertical>);\n"}],"height":"300px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>If your input allows invalid <em>strings</em> to be input then you should add a validator to the FileState<string>. You can then create a utility to read the Display as TValue only if its been validated. E.g. if you use a keyboard driven date input:</p></div>"},{"type":"app","index":9,"htmlFileName":"app-9.html","sources":[{"mode":"js","code":"/** React + MUI + mobx + moment */\nimport * as React from 'react';\nimport { render, Button, ErrorText, labelClass, inputClass } from './mui';\nimport { observer } from 'mobx-react';\nimport { Vertical } from './gls';\nimport moment from 'moment';\n\n/** FieldState */\nimport { FieldState } from '../../index';\n\n\n/** Example date parsing and validator */\ntype ParseDateResult =\n  | { valid: false }\n  | { valid: true, date: Date };\n\n/** only allows AUSTRALIAN format */\nconst parseDate = (value: string): ParseDateResult => {\n  let date = moment(value, ['DD/MM/YYYY'], true);\n  if (!date.isValid()) {\n    return { valid: false };\n  }\n  return { valid: true, date: date.toDate() };\n}\n\n/** Call if you are sure that string is a valid date */\nconst stringToDate = (value: string): Date => {\n  return moment(value, ['DD/MM/YYYY'], true).toDate();\n}\n\n/** Example date FieldState */\nconst fieldState = new FieldState<string>('')\n  .validators(\n    (val) => {\n      if (!val.trim()) return null;\n      const { valid } = parseDate(val);\n      if (!valid) return 'Date must be of format DD/MM/YYYY';\n    },\n  );\n\n/** Example DateInputField */\ntype DateInputFieldProps = {\n  fieldState: FieldState<string | null>,\n  label: string\n};\nconst DateInputField: React.SFC<DateInputFieldProps> = observer((props: DateInputFieldProps) => {\n  return (\n    <label>\n      <span className={labelClass}>{props.label}</span>\n      <input\n        className={inputClass}\n        value={\n          props.fieldState.value == null\n            ? ''\n            : props.fieldState.value.toString()\n        }\n        onChange={(e) => {\n          props.fieldState.onChange(e.target.value);\n        }}\n      />\n    </label>\n  );\n});\n\n\n\nrender(() => <Vertical margin={10}>\n  <DateInputField\n    label=\"Date of registry (DD/MM/YYYY)\"\n    fieldState={fieldState} />\n  {fieldState.hasError && <ErrorText>Current Field Error = {fieldState.error}</ErrorText>}\n  <Button onClick={fieldState.validate}>Validate</Button>\n  {\n    fieldState.$.trim()\n    && fieldState.hasBeenValidated\n    && !fieldState.hasError && `Date object: ${stringToDate(fieldState.$)}`}\n</Vertical>);\n"}],"height":"300px","pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h1>\n      DisplayValue\n      <a name=\"displayvalue\" class=\"heading-anchor\" href=\"#displayvalue\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h1><p>A number of browser inputs (<code>select</code>, <code>radio</code>, <code>checkbox</code>) work on the concept of:</p>\n<ul>\n<li>Something displayed to the user</li>\n<li>A value mapped behind what is displayed to the user.</li>\n</ul>\n<p>You can create a <code>DisplayValue</code> object to consolidate these two items:</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\"><span class=\"hljs-keyword\">export</span> type DisplayValue = {\n  <span class=\"hljs-attr\">display</span>: string,\n  <span class=\"hljs-attr\">value</span>: string\n}</div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Your validators would now validate the <code>DisplayValue.value</code> e.g. a displayValueRequired validator:</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\"><span class=\"hljs-keyword\">import</span> { DisplayValue } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./displayValue\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> displayValueRequired\n  = <span class=\"hljs-function\">(<span class=\"hljs-params\">val: DisplayValue</span>) =&gt;</span> !val.value.trim() &amp;&amp; <span class=\"hljs-string\">'Value required'</span>;</div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Next we cover the select, radio, checkbox fields seperately</p></div>"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><h2>\n      Select\n      <a name=\"select\" class=\"heading-anchor\" href=\"#select\" aria-hidden=\"true\">\n        <svg aria-hidden=\"true\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\" height=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\n      </a>\n    </h2><p>Our <code>SelectField</code> will take a <code>FieldState</code> and <code>displayValues</code> and renders the select and option tags:</p></div>"},{"type":"code","html":"<div class=eze-markdown><pre><code><div style=\"display: inline-block\"><span class=\"hljs-comment\">/** Material UI */</span>\n<span class=\"hljs-keyword\">import</span> { FormControl, InputLabel, Select, MenuItem } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@material-ui/core'</span>;\n\n\n<span class=\"hljs-keyword\">export</span> type SelectFieldProps = {\n  <span class=\"hljs-comment\">/** This library : fieldState */</span>\n  fieldState: FieldState&lt;DisplayValue&gt;,\n\n  <span class=\"hljs-comment\">/** Select fields take a list of options */</span>\n  displayValues: DisplayValue[],\n\n  <span class=\"hljs-comment\">/**\n   * Any UI stuff you need\n   * Use your imagination ðŸ¦„!\n   */</span>\n  id: string,\n  <span class=\"hljs-attr\">label</span>: string,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> SelectField = observer(<span class=\"hljs-function\">(<span class=\"hljs-params\">props: SelectFieldProps</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FormControl</span> <span class=\"hljs-attr\">fullWidth</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">InputLabel</span>\n      <span class=\"hljs-attr\">error</span>=<span class=\"hljs-string\">{props.fieldState.hasError}</span>\n      <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">{props.id}</span>&gt;</span>\n      {props.label}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">InputLabel</span>&gt;</span>\n    {/** \n     * Render a select, wiring its value and onChange to fieldState \n     */}\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Select</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{props.fieldState.value}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =&gt;</span> {\n        props.fieldState.onChange(\n          props.displayValues.find(option =&gt; option.value == e.target.value)!\n        )\n      }}\n      inputProps={{\n        id: props.id\n      }}\n    &gt;\n      {/** Render the options */}\n      {props.displayValues.map(displayValue =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MenuItem</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{displayValue.value}</span>&gt;</span>{displayValue.display}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MenuItem</span>&gt;</span>\n      ))}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">FormControl</span>&gt;</span></span>\n));</div></code></pre></div>","collapsed":false,"pageSubDirName":"all"},{"type":"html","pageSubDirName":"all","html":"<div class=eze-markdown><p>Once that is done you now get to use your new shiny <code>SelectField</code> with complete compile time safety.</p></div>"},{"type":"app","index":10,"htmlFileName":"app-10.html","sources":[{"mode":"js","code":"/** React + MUI + mobx*/\nimport * as React from 'react';\nimport { render } from './mui';\n\n/** Field */\nimport { DisplayValue } from './displayValue';\nimport { SelectField } from './selectField';\n\n/** FieldState */\nimport { FieldState } from '../../index';\nconst fieldState = new FieldState<DisplayValue>({ display: 'Please select', value: '' })\n  .validators((val: DisplayValue) => !val.value.trim() && 'Value required');\n\nrender(() => <div>\n  <SelectField\n    id=\"question\"\n    label=\"Type of vehicle\"\n    fieldState={fieldState}\n    displayValues={[\n      { display: 'Please select', value: '' },\n      { display: 'I drive a car', value: 'car' },\n      { display: 'I drive a truck', value: 'truck' },\n    ]}\n  />\n  {!!fieldState.value.value && <p>Current Field Display = {fieldState.value.display}</p>}\n  {!!fieldState.value.value && <p>Current Field Value = {fieldState.value.value}</p>}\n  {fieldState.hasError && <p>Current Field Error = {fieldState.error}</p>}\n</div>);\n"}],"height":"300px","pageSubDirName":"all"}],"tableOfContents":[{"type":"pageRoot","heading":"FormState Demos","pageSubDirName":"all"},{"type":"pageSub","id":"creating-a-field","level":1,"pageSubDirName":"all","text":"Creating a Field"},{"type":"pageSub","id":"validation-triggering","level":1,"pageSubDirName":"all","text":"Validation Triggering"},{"type":"pageSub","id":"formstate","level":1,"pageSubDirName":"all","text":"FormState"},{"type":"pageSub","id":"cross-field-validation","level":1,"pageSubDirName":"all","text":"Cross field validation"},{"type":"pageSub","id":"custom-type-tvalue","level":1,"pageSubDirName":"all","text":"Custom type TValue"},{"type":"pageSub","id":"displayvalue","level":1,"pageSubDirName":"all","text":"DisplayValue"},{"type":"pageSub","id":"select","level":2,"pageSubDirName":"all","text":"Select"}]}